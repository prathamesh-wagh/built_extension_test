var express     = require('express')
var fs          = require('fs')
var nconf       = require("nconf")

GLOBAL.utils = require('./utils')

var router      = require('../router')
var setupConfig = require('../config')
var autoRequire = require('./auto-require')
var bodyParser  = require('body-parser')

/*process.on('SIGINT', terminateServer)

process.on('SIGTERM', terminateServer)

function terminateServer(){
  module.exports.shutdown()
}*/

var FrameworkApp = function(){
  this.app = express()

  /**
   * Sets envirnoment varaible on app
   */
  this.app.env = process.env.NODE_ENV || "test"

  /*
   Getter setter methods for app configs
  */
  this.app.config = nconf
  /*
    Binds expressJS standard middlewares 
  */
  this.app.use(bodyParser.json({limit: '50mb'}))
  this.app.use(bodyParser.urlencoded({extended: true, limit: '50mb', type: 'application/x-www-form-urlencoded'}))

  // Catches error thrown by body parser and handles it
  this.app.use(function (error, req, res, next) {
    if (error){
      if(error instanceof SyntaxError) {
        res.status(400).send({
          error_message: "Malformed Body"
        })
      }
      else {
        res.status(400).send({
          error_message: error.message
        })
      }
    } else {
      next();
    }
  })
}

/*
    Add more configs
  */
  FrameworkApp.prototype.mergeConfig = function(name, config) {
    this.app.config.add(name, { type: 'literal', store: utils.extend(config['defaults']||{}, config[this.app.env]) })
  }

  /*
    Tasks to be performed before a process is retired during deployment
  */
  FrameworkApp.prototype.beforeDeploy = function(task) {
    this.app.beforeDeployTasks = this.app.beforeDeployTasks || []
    this.app.beforeDeployTasks.push(task)
  }

  /*
    This method add new errorCodes to global configs
  */
  FrameworkApp.prototype.configureErrorCodes = function(name, errorCodes) {
    this.app.config.add(name, { type: 'literal', store:{"errorCodes": errorCodes }})
  }

  /*
    Traverse and require the JS files
  */
  FrameworkApp.prototype.requireJSFilesForDirectory = function(dir) {
    return autoRequire.traverseAndRequire(dir)
  }

  /*
    Returns appropriate error code method from global config
  */
  FrameworkApp.prototype.errorCodes = function(key){
    return this.app.config.get('errorCodes')[key]
  }

FrameworkApp.prototype.static = function() {
  return express.static
}

FrameworkApp.prototype.start = function() {
  var that = this
  return this.startWithPort(that.app.config.get('server:port'))
}

/*FrameworkApp.prototype.stop = function() {
  var that = this
  var liftedClose = utils.Promise.wrapNodeFnInPromise(that.app.listener.close)
  return liftedClose()
}
*/
FrameworkApp.prototype.stop = function(){
  var deferred = utils.Promise.defer()
  this.app.listener.close(function(err){
    if(err)
      deferred.reject(err)

    deferred.resolve()
  })
  return deferred.promise
},

// starts the app on an undefined port, randomly selected
FrameworkApp.prototype.startOnRandomPort = function() {
  return this.startWithPort()
}

FrameworkApp.prototype.getAppInstance = function() {
  return this.app
}

// really start the app on a port
FrameworkApp.prototype.startWithPort = function(port) {
  var that = this
  var deferred = utils.Promise.defer()
  that.app.listener = that.app.listen(port, function(err, data) {
    // Server Error
    if (err)
      deferred.reject()

    // Un-necessary logs for test env
    if(process.env.NODE_ENV !== "test"){
      try {
        console.log('Listening over HTTP on port %s:', that.app.listener.address().port, "Envirnoment:", that.app.env)
      } catch (e) {
        // listener.address() was null
        console.log('Listening over HTTP on port %s:', port, "Envirnoment:", that.app.env)
      }
    }
    // Notify at process level that the server is up and running (Required for naught)
    that.notifyOnline()

    deferred.resolve()
  })

  return deferred.promise
}
  // notify that this app is online
FrameworkApp.prototype.notifyOnline = function() {
  var that = this
    // if this is a multiprocess naught app
  if (process.send) {
    // this worker is online
    process.send('ready')
    process.send('online')

    if (that.app.config.get('suicideTimeout')) {
      // convert hours to ms
      var timeout = (that.app.config.get('suicideTimeout') * 60 * 60 * 1000) + Math.random() * 5000

      setTimeout(function() {
        process.send('offline')
        that.shutdown()
      }, timeout)
    }

    // to gracefully shutdown
    process.on('message', function(message) {
      if (message === 'shutdown') {
        that.shutdown()
      }
    })
  }
}

FrameworkApp.prototype.shutdown = function() {
  var that = this
  try {
    that.app.beforeDeploy(function(done) {
      try {
        that.app.close && app.close()
        utils.Promise.resolve()
      } catch (e) {
        done()
      }
    })

    // Runs all before terminates tasks
    utils.Promise.sequence(that.app.beforeDeployTasks)
      .then(function() {
        // Exits the process once every booking task in complete
        process.exit(0)
      })

    // a hard timeout of 2 sec for closing everything
    setTimeout(function() {
      process.exit(0)
    }, 2000)
  } catch (e) {
    process.exit(0)
  }
}

module.exports = function(){
  var inst =  new FrameworkApp()
  /*
    Merges setup configs
  */
  inst.mergeConfig('setup_conf', setupConfig)

  return inst
}

