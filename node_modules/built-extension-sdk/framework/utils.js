module.exports                                = require('lodash')
module.exports.Promise                        = require('when')
module.exports.Promise.sequence               = require('when/sequence')
module.exports.Promise.pipeline               = require('when/pipeline')
module.exports.Promise.parallel               = require('when/parallel');
module.exports.Promise.wrapFnInPromise        = require('when/function').lift
module.exports.Promise.wrapNodeFnInPromise    = require('when/node').lift
module.exports.Promise.wrapAllNodeFnInPromise = require('when/node').liftAll

/**
 * This promise will never be resolved
 */
module.exports.Promise.deferredPromise        = module.exports.Promise.defer().promise

module.exports.wrapInPromise     = function(toBeWrapped){
  return when(toBeWrapped)
}

module.exports.Promise.wrapAllFnInPromise = function(fns){
  return fns.map(function(fn){
    return module.exports.Promise.wrapFnInPromise(fn)
  })
}

/*
  Compatibility with q
*/
module.exports.Promise.fcall = module.exports.Promise.try
module.exports.Promise.allSettled = module.exports.Promise.settle
// module.exports.Promise.node = nodeP
// module.exports.Promise.nfcall = module.exports.Promise.node.call
// module.exports.Promise.makeNodeResolver = module.exports.Promise.node.createCallback
module.exports.Promise.isPromise = module.exports.Promise.isPromiseLike
module.exports.Promise.when = function(val, cb) {
  return module.exports.Promise(val).then(cb)
}
module.exports.Promise.delay = function(delay) {return module.exports.Promise().delay(delay)}
module.exports.Promise.Promise.prototype.fail = module.exports.Promise.Promise.prototype.catch
module.exports.Promise.Promise.prototype.get = function(key) {
  return this
    .then(function(val) {
      return val[key]
    })
}
module.exports.Promise.Promise.prototype.anyways = function(cb) {
  return this.then(cb, cb)
}
module.exports.Promise.Promise.prototype.isPending = function() {
  return this.inspect().state === 'pending'
}
module.exports.Promise.Promise.prototype.isRejected = function() {
  return this.inspect().state === 'rejected'
}
module.exports.Promise.Promise.prototype.isFulfilled = function() {
  return this.inspect().state === 'fulfilled'
}

/*
  Executes an async function with a context
  Returns a promise that will be called with the async data
  The callback will be in the node form of cb(error, data)
  @example
    module.exports.Promise.npromise(context, method, arguments)
*/
module.exports.Promise.npromise = function() {
  var context = arguments[0]
  var fn      = arguments[1]
  var rest    = Array.prototype.slice.call(arguments, 2, arguments.length)
  
  var deferred = module.exports.Promise.defer()

  rest.push(function(e, data) {
    if (e)
      return deferred.reject(e)
    else
      return deferred.resolve(data)
  })
  context[fn].apply(context, rest)
  return deferred.promise
}

/*
  Converts a callback based function into promise
  Similar to npromise, except the callback is of the form cb(data)
*/
module.exports.Promise.cpromise = function() {
  var context = arguments[0]
  var fn = arguments[1]
  var rest = Array.prototype.slice.call(arguments, 2, arguments.length)

  var deferred = module.exports.Promise.defer()

  rest.push(function(data) {
    return deferred.resolve(data)
  })

  context[fn].apply(context, rest)
  return deferred.promise  
}

module.exports.Promise.Promise.prototype.anyways = function(cb) {
  return this.then(cb, cb)
}

// HelperFunction | Returns a rejected promise if the return value is false
module.exports.Promise.rejectIfFalsy = function(prom){
  return prom
  .then(function(bool){

    if(bool === false)
      return utils.Promise.reject(false)

    return true
  })
}

/*
  Allows you to specify an object inline
  Helps you turn this:
    var a = 'mykey'
    var b = {}
    b[a] = 'myvalue'

  into: 

    var b = module.exports.keyVal('mykey', 'myvalue')

  @param key, value any number of pairs of keys and values
  @return object The resulting object
*/
module.exports.keyVal = function() {
  var lastKey = null
  var result  = {}

  for (var i = 0; i < arguments.length; i++) {
    var elem = arguments[i]
    if ((i % 2) === 0) {
      lastKey = elem
    } else {
      result[lastKey] = elem
    }
  }

  return result
}

/**
 * Returns true if value is undefind or null
 * @param  {[type]}  value [description]
 * @return {Boolean}       [description]
 */
module.exports.isNil = function(value){
  return utils.isUndefined(value) || utils.isNull(value)
}

/*
  Debugging logs
  0 - Don't debug
  1 - Error debug
  2 - Warn Debug
  3 - Info Debug
*/
GLOBAL.d = function() {
  d.info.apply(d, arguments)
}

d.levels = {
  none : 0,
  error: 1,
  warn : 2,
  log  : 3,
  info : 4
}

d.spliceArgs = function(flag, args) {
  var newArgs = [flag]
  Object.keys(args).forEach(function(key) {
    newArgs.push(args[key])
  })
  return newArgs
}

d.info = function() {
  if (app.config.get('debug') > d.levels.warn) {
    arguments = d.spliceArgs((new Date).toISOString() + ' : info : ', arguments)
    console.info.apply(console, arguments)
  }
}

d.log = function(){
  if (app.config.get('debug') > d.levels.warn) {
    arguments = d.spliceArgs((new Date).toISOString() + ' : info : ', arguments)
    console.info.apply(console, arguments)
  } 
}

d.warn = function() {
  if (app.config.get('debug') > d.levels.error) {
    arguments = d.spliceArgs((new Date).toISOString() + ' : warn : ', arguments)
    console.warn.apply(console, arguments)
  }
}

d.error = function() {
  if (app.config.get('debug') > d.levels.none) {
    arguments = d.spliceArgs((new Date).toISOString() + ' : error : ', arguments)
    console.error.apply(console, arguments)
  }
}